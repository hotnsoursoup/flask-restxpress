Got it! You want to have separate YAML files for different entities like users and customers, where each file includes both the paths and the components (schemas). Then, you will merge these YAML files at runtime and dynamically generate Pydantic models.

Here's how you can do it:

Step-by-Step Guide
Organize Your OpenAPI YAML Files
Create separate YAML files for users and customers, each containing both the paths and the components.

openapi.yaml (main file):

yaml
Copy code
openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components: {}
users.yaml:

yaml
Copy code
paths:
  /users:
    post:
      summary: Create a new user
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateUserRequest'
      responses:
        '201':
          description: User created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateUserResponse'
    get:
      summary: List all users
      responses:
        '200':
          description: A list of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
  /users/{user_id}:
    get:
      summary: Get a user by ID
      parameters:
        - name: user_id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: User details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        username:
          type: string
        email:
          type: string
    CreateUserRequest:
      type: object
      properties:
        username:
          type: string
        email:
          type: string
    CreateUserResponse:
      type: object
      properties:
        id:
          type: integer
        username:
          type: string
        email:
          type: string
customers.yaml:

yaml
Copy code
paths:
  /customers:
    post:
      summary: Create a new customer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateCustomerRequest'
      responses:
        '201':
          description: Customer created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateCustomerResponse'
    get:
      summary: List all customers
      responses:
        '200':
          description: A list of customers
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Customer'
  /customers/{customer_id}:
    get:
      summary: Get a customer by ID
      parameters:
        - name: customer_id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Customer details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Customer'
components:
  schemas:
    Customer:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        email:
          type: string
    CreateCustomerRequest:
      type: object
      properties:
        name:
          type: string
        email:
          type: string
    CreateCustomerResponse:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        email:
          type: string
Load and Merge YAML Files
Write a function to load and merge these YAML files at runtime.

main.py:

python
Copy code
import yaml
from fastapi import FastAPI, HTTPException, Path
from pydantic import BaseModel
from typing import List
from datamodel_code_generator import InputFileType, generate

app = FastAPI()

def load_yaml_file(file_path: str) -> dict:
    with open(file_path, 'r') as f:
        return yaml.safe_load(f)

def merge_openapi_specs(*specs: List[dict]) -> dict:
    merged_spec = {'openapi': '3.0.0', 'info': {'title': 'API', 'version': '1.0.0'}, 'paths': {}, 'components': {'schemas': {}}}
    for spec in specs:
        merged_spec['paths'].update(spec.get('paths', {}))
        merged_spec['components']['schemas'].update(spec.get('components', {}).get('schemas', {}))
    return merged_spec

# Load and merge the OpenAPI YAML files
openapi_spec = merge_openapi_specs(
    load_yaml_file('openapi.yaml'),
    load_yaml_file('users.yaml'),
    load_yaml_file('customers.yaml')
)

# Generate Pydantic models dynamically
def generate_models_from_openapi(openapi_spec: dict) -> dict:
    models_code = generate(
        input_data=yaml.dump(openapi_spec),
        input_file_type=InputFileType.OpenAPI,
        target_python_version="3.8"
    )
    namespace = {}
    exec(models_code, namespace)
    return namespace

models_namespace = generate_models_from_openapi(openapi_spec)

# Access the dynamically generated models
User = models_namespace['User']
CreateUserRequest = models_namespace['CreateUserRequest']
CreateUserResponse = models_namespace['CreateUserResponse']
Customer = models_namespace['Customer']
CreateCustomerRequest = models_namespace['CreateCustomerRequest']
CreateCustomerResponse = models_namespace['CreateCustomerResponse']

# In-memory databases
users = []
customers = []

@app.post("/users", response_model=CreateUserResponse)
def create_user(user_request: CreateUserRequest):
    new_user = User(id=len(users) + 1, username=user_request.username, email=user_request.email)
    users.append(new_user.dict())
    return CreateUserResponse(id=new_user.id, username=new_user.username, email=new_user.email)

@app.get("/users/{user_id}", response_model=User)
def get_user(user_id: int = Path(..., title="The ID of the user to retrieve", ge=1)):
    user = next((u for u in users if u['id'] == user_id), None)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@app.get("/users", response_model=List[User])
def list_users():
    return users

@app.post("/customers", response_model=CreateCustomerResponse)
def create_customer(customer_request: CreateCustomerRequest):
    new_customer = Customer(id=len(customers) + 1, name=customer_request.name, email=customer_request.email)
    customers.append(new_customer.dict())
    return CreateCustomerResponse(id=new_customer.id, name=new_customer.name, email=new_customer.email)

@app.get("/customers/{customer_id}", response_model=Customer)
def get_customer(customer_id: int = Path(..., title="The ID of the customer to retrieve", ge=1)):
    customer = next((c for c in customers if c['id'] == customer_id), None)
    if customer is None:
        raise HTTPException(status_code=404, detail="Customer not found")
    return customer

@app.get("/customers", response_model=List[Customer])
def list_customers():
    return customers

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)